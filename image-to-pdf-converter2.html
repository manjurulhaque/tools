<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced Image → PDF Converter</title>

<!-- External libraries (CDN) -->
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<link  href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/exifreader@4.12.0/dist/exif-reader.min.js"></script>

<style>
  :root{
    --bg:#f5f7fb; --panel:#fff; --accent:#1f6feb; --muted:#667085;
    --radius:10px;
  }
  html,body{height:100%; margin:0; font-family:Inter, Roboto, Arial, sans-serif; background:var(--bg); color:#0b1220;}
  .app {
    max-width:1200px; margin:28px auto; padding:22px; background:linear-gradient(180deg,#ffffff 0%, #fbfdff 100%); border-radius:14px; box-shadow:0 8px 30px rgba(20,30,60,0.06);
  }
  h1{margin:0 0 12px; font-size:20px;}
  .top {display:flex; gap:18px; align-items:flex-start;}
  .left, .right {background:var(--panel); padding:16px; border-radius:12px; box-shadow:0 2px 10px rgba(17,24,39,0.04);}
  .left {flex:1; min-width:420px;}
  .right {width:360px;}
  .dropzone {
    border:2px dashed #dbe6ff; border-radius:10px; padding:20px; text-align:center; background:linear-gradient(180deg, rgba(31,111,235,0.03), transparent);
    cursor:pointer; transition:background .12s;
  }
  .dropzone.dragover { background:linear-gradient(180deg, rgba(31,111,235,0.08), transparent); }
  .controls { display:flex; gap:8px; margin-top:12px; align-items:center; flex-wrap:wrap;}
  .btn { background:var(--accent); color:white; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; font-weight:600;}
  .btn.secondary{ background:#eef4ff; color:var(--accent); }
  .thumbs { display:flex; gap:10px; margin-top:14px; overflow:auto; padding:6px; }
  .thumb { width:110px; min-width:110px; background:#fafbfd; border-radius:8px; padding:8px; display:flex; flex-direction:column; gap:8px; align-items:center; justify-content:center; position:relative;}
  .thumb img { max-width:100%; max-height:70px; display:block; border-radius:6px; background:#fff; object-fit:contain; }
  .thumb .actions { display:flex; gap:6px; }
  .thumb .smallbtn { padding:6px 8px; border-radius:6px; border:1px solid #e6eefc; background:white; cursor:pointer; font-size:12px; }
  .meta { display:flex; gap:8px; margin-top:8px; align-items:center; }
  label { font-size:13px; color:var(--muted); display:block; margin-bottom:6px;}
  input[type="text"], select, input[type="number"], textarea {
    width:100%; padding:8px 10px; border-radius:8px; border:1px solid #e6eefc; background:white; box-sizing:border-box;
  }
  .field { margin-bottom:12px; }
  .section-title { font-weight:700; margin:8px 0; font-size:14px; }
  .right .generate { width:100%; margin-top:10px; display:flex; gap:8px; }
  .progress { height:10px; background:#eef2ff; border-radius:999px; overflow:hidden; }
  .progress > i { display:block; height:100%; width:0%; background:linear-gradient(90deg,#2b7cff,#69b3ff); transition:width .2s ease; }
  .footer { margin-top:14px; font-size:12px; color:var(--muted); }
  .modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(5,8,20,0.45); z-index:40;}
  .modal.show { display:flex; }
  .cropper-container { width:80vw; height:80vh; background:#111; padding:12px; border-radius:10px; display:flex; flex-direction:column; gap:10px; }
  .crop-area { flex:1; display:flex; align-items:center; justify-content:center; background:#fff; overflow:auto; }
  .crop-controls { display:flex; gap:8px; justify-content:flex-end; }
  .small { font-size:12px; padding:6px 8px; border-radius:8px; }
  .top-right { display:flex; gap:8px; align-items:center; margin-left:auto; }
  .muted { color:var(--muted); font-size:13px; }
  .help { font-size:13px; color:var(--muted); margin-top:8px; }
</style>
</head>
<body>
<div class="app">
  <div style="display:flex;align-items:center;gap:12px;">
    <h1>Advanced Image → PDF Converter</h1>
    <div class="muted">Client-side, privacy-first. Reorder, crop, rotate, compress, watermark, set page size and export.</div>
  </div>
  <div class="top" style="margin-top:12px;">
    <div class="left">
      <div id="dropzone" class="dropzone" tabindex="0">
        <div style="font-weight:700">Drag & drop images here</div>
        <div class="muted">or click to browse. Supports PNG, JPEG, WebP. Paste images too (Ctrl+V).</div>
        <div class="controls">
          <input id="fileInput" type="file" accept="image/*" multiple style="display:none"/>
          <button class="btn" id="btnBrowse">Browse files</button>
          <button class="btn secondary" id="btnClear">Clear all</button>
          <div style="margin-left:auto; display:flex; gap:6px; align-items:center;">
            <label class="muted" style="margin:0 6px 0 0">Images</label>
            <div id="count" class="muted">0</div>
          </div>
        </div>
      </div>

      <div id="thumbs" class="thumbs" aria-live="polite"></div>

      <div class="section-title">Selected image settings</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <div style="flex:1; min-width:220px;">
          <label>Global fit mode</label>
          <select id="fitMode">
            <option value="contain">Fit (contain)</option>
            <option value="cover">Fill (cover)</option>
            <option value="stretch">Stretch (may distort)</option>
            <option value="center">Center (no scale)</option>
          </select>
        </div>
        <div style="width:150px;">
          <label>Compression quality</label>
          <input id="quality" type="range" min="0.2" max="1" step="0.05" value="0.9"/>
        </div>
        <div style="width:130px;">
          <label>DPI</label>
          <input id="dpi" type="number" min="72" max="600" value="150"/>
        </div>
      </div>

      <div style="display:flex; gap:10px; margin-top:8px;">
        <button id="btnRotateLeft" class="smallbtn" style="padding:8px 10px;">Rotate ⟲</button>
        <button id="btnRotateRight" class="smallbtn" style="padding:8px 10px;">Rotate ⟳</button>
        <button id="btnCrop" class="smallbtn" style="padding:8px 10px;">Open Crop</button>
        <button id="btnAutoOrient" class="smallbtn" style="padding:8px 10px;">Auto-orient (EXIF)</button>
      </div>

      <div class="section-title">Watermark</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="watermarkText" type="text" placeholder="Optional watermark text (e.g. Confidential)"/>
        <input id="watermarkOpacity" type="range" min="0" max="1" step="0.05" value="0.25" style="width:120px"/>
      </div>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <label style="width:90px">Font size</label>
        <input id="watermarkSize" type="number" min="8" max="72" value="24" style="width:80px"/>
        <label style="width:90px">Position</label>
        <select id="watermarkPos" style="width:160px">
          <option value="center">Center</option>
          <option value="top-left">Top-left</option>
          <option value="top-right">Top-right</option>
          <option value="bottom-left">Bottom-left</option>
          <option value="bottom-right">Bottom-right</option>
        </select>
      </div>

      <div class="help">Tip: crop or rotate specific thumbnails by selecting the thumbnail controls; re-order pages by dragging thumbnails.</div>
    </div>

    <div class="right">
      <div class="field">
        <label>Page size</label>
        <select id="pageSize">
          <option value="A4">A4 (210 × 297 mm)</option>
          <option value="Letter">Letter (8.5 × 11 in)</option>
          <option value="Legal">Legal (8.5 × 14 in)</option>
          <option value="Custom">Custom (mm)</option>
        </select>
      </div>
      <div id="customSizeRow" style="display:none; gap:8px; margin-bottom:12px;">
        <div>
          <label>Width (mm)</label>
          <input id="customW" type="number" min="10" value="210"/>
        </div>
        <div>
          <label>Height (mm)</label>
          <input id="customH" type="number" min="10" value="297"/>
        </div>
      </div>

      <div class="field">
        <label>Orientation</label>
        <select id="orientation">
          <option value="portrait">Portrait</option>
          <option value="landscape">Landscape</option>
        </select>
      </div>

      <div class="field">
        <label>Margins (mm)</label>
        <input id="margins" type="number" min="0" value="10"/>
      </div>

      <div class="field">
        <label>PDF metadata</label>
        <input id="pdfTitle" type="text" placeholder="Title"/>
        <input id="pdfAuthor" type="text" placeholder="Author" style="margin-top:8px"/>
        <input id="pdfSubject" type="text" placeholder="Subject" style="margin-top:8px"/>
      </div>

      <div class="field">
        <label>Output filename</label>
        <input id="outName" type="text" value="document.pdf" />
      </div>

      <div class="field">
        <label>Advanced options</label>
        <div style="display:flex; gap:8px;">
          <label style="display:flex; gap:6px; align-items:center;"><input id="embedAsJpg" type="checkbox" checked/> Embed as JPEG when possible</label>
        </div>
      </div>

      <div class="generate">
        <button class="btn" id="btnGenerate">Generate PDF</button>
        <button class="btn secondary" id="btnPreview">Preview 1st page</button>
      </div>

      <div style="margin-top:12px;">
        <div class="progress"><i id="progressBar"></i></div>
        <div style="display:flex; gap:10px; margin-top:8px; align-items:center;">
          <div class="muted">Status:</div>
          <div id="status" class="muted">Idle</div>
        </div>
      </div>

      <div class="footer">
        <div>Compatible with modern browsers. Large files may consume memory. For very large batches, consider server-side processing.</div>
      </div>
    </div>
  </div>
</div>

<!-- Crop modal -->
<div id="modal" class="modal" aria-hidden="true">
  <div class="cropper-container">
    <div style="display:flex; align-items:center; gap:10px;">
      <div style="font-weight:700">Crop / Adjust</div>
      <div class="top-right">
        <button id="cropRotateLeft" class="small">Rotate ⟲</button>
        <button id="cropRotateRight" class="small">Rotate ⟳</button>
        <button id="cropReset" class="small">Reset</button>
      </div>
    </div>
    <div class="crop-area">
      <img id="cropImg" style="max-width:100%; max-height:100%; display:block;" />
    </div>
    <div class="crop-controls">
      <button id="cropCancel" class="small">Cancel</button>
      <button id="cropApply" class="small" style="background:#1f6feb;color:white;border:none;">Apply</button>
    </div>
  </div>
</div>

<script>
/*
  Advanced Image -> PDF Converter
  - Uses pdf-lib to build PDF pages.
  - Thumbnails store per-image state: rotation, cropRect, filename, imageDataURL, originalFile, index
  - Reordering via SortableJS.
  - Crop using Cropper.js in modal.
  - EXIF orientation read with ExifReader.
*/

const { PDFDocument, StandardFonts, rgb } = window.PDFLib;

const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const btnBrowse = document.getElementById('btnBrowse');
const btnClear = document.getElementById('btnClear');
const thumbsEl = document.getElementById('thumbs');
const countEl = document.getElementById('count');
const btnGenerate = document.getElementById('btnGenerate');
const btnPreview = document.getElementById('btnPreview');
const progressBar = document.getElementById('progressBar');
const statusEl = document.getElementById('status');
const fitModeEl = document.getElementById('fitMode');
const qualityEl = document.getElementById('quality');
const dpiEl = document.getElementById('dpi');
const pageSizeEl = document.getElementById('pageSize');
const orientationEl = document.getElementById('orientation');
const marginsEl = document.getElementById('margins');
const customSizeRow = document.getElementById('customSizeRow');
const customW = document.getElementById('customW');
const customH = document.getElementById('customH');
const outNameEl = document.getElementById('outName');
const watermarkTextEl = document.getElementById('watermarkText');
const watermarkOpacityEl = document.getElementById('watermarkOpacity');
const watermarkSizeEl = document.getElementById('watermarkSize');
const watermarkPosEl = document.getElementById('watermarkPos');
const embedAsJpgEl = document.getElementById('embedAsJpg');

let images = []; // array of {id, file, dataUrl, rotation, cropData, name, width, height}
let currentCropIndex = null;
let cropper = null;

/* Utility: create unique id */
function uid() { return Math.random().toString(36).slice(2,9); }

/* Handle page size preset -> mm -> points conversion later (1 pt = 1/72 in). We'll convert mm to points. */
function mmToPoints(mm) { return mm * 2.8346456693; } // 1 mm = 2.8346456693 points

const PAGE_PRESETS = {
  'A4': { w_mm:210, h_mm:297 },
  'Letter': { w_in:8.5, h_in:11 },
  'Legal': { w_in:8.5, h_in:14 }
};

function updateCount(){ countEl.textContent = images.length; }

/* Add file list events */
btnBrowse.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', (e)=> handleFiles(e.target.files));
btnClear.addEventListener('click', ()=> { images = []; renderThumbs(); });

/* Drag & drop support */
;['dragenter','dragover'].forEach(ev => {
  dropzone.addEventListener(ev, (e)=> { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover');});
});
;['dragleave','drop'].forEach(ev => {
  dropzone.addEventListener(ev, (e)=> { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover');});
});
dropzone.addEventListener('drop', (e)=>{
  const dt = e.dataTransfer;
  if(dt && dt.files) handleFiles(dt.files);
});
dropzone.addEventListener('click', ()=> fileInput.click());

/* Paste support */
window.addEventListener('paste', (e)=>{
  if(e.clipboardData){
    const items = e.clipboardData.items;
    const list = [];
    for(let i=0;i<items.length;i++){
      const it = items[i];
      if(it.type.indexOf('image') !== -1){
        const file = it.getAsFile();
        if(file) list.push(file);
      }
    }
    if(list.length) handleFiles(list);
  }
});

/* Handle reading files */
async function handleFiles(fileList){
  const files = Array.from(fileList).filter(f=>f.type.startsWith('image/'));
  if(files.length === 0) return;
  status('Reading ' + files.length + ' files...');
  for(const f of files){
    const id = uid();
    const dataUrl = await fileToDataURL(f);
    // read natural size
    const dims = await getImageSize(dataUrl);
    // attempt read EXIF orientation
    let orientation = 1;
    try{
      const tags = ExifReader.load(await f.arrayBuffer());
      if(tags && tags.Orientation && tags.Orientation.value) orientation = tags.Orientation.value;
    }catch(err){ /* ignore */ }

    images.push({
      id, file: f, name: f.name, dataUrl, rotation: 0, cropData: null,
      width: dims.width, height: dims.height, exifOrientation: orientation
    });
  }
  renderThumbs();
  status('Loaded ' + images.length + ' images');
}

/* helper read file to dataURL */
function fileToDataURL(file){
  return new Promise((resolve, reject)=>{
    const fr = new FileReader();
    fr.onload = ()=> resolve(fr.result);
    fr.onerror = reject;
    fr.readAsDataURL(file);
  });
}
function getImageSize(dataUrl){
  return new Promise((res, rej)=>{
    const img = new Image();
    img.onload = ()=> res({width:img.naturalWidth, height:img.naturalHeight});
    img.onerror = rej;
    img.src = dataUrl;
  });
}

/* Render thumbnails */
function renderThumbs(){
  thumbsEl.innerHTML = '';
  images.forEach((img, index) => {
    const div = document.createElement('div');
    div.className = 'thumb';
    div.dataset.id = img.id;
    div.innerHTML = `
      <img src="${img.dataUrl}" alt="${escapeHtml(img.name)}"/>
      <div style="font-size:12px; text-align:center; word-break:break-word;">${escapeHtml(img.name)}</div>
      <div class="actions">
        <button class="smallbtn rotate-left">⟲</button>
        <button class="smallbtn rotate-right">⟳</button>
        <button class="smallbtn crop">Crop</button>
        <button class="smallbtn remove">✕</button>
      </div>
    `;
    thumbsEl.appendChild(div);

    // attach listeners
    div.querySelector('.rotate-left').addEventListener('click', ()=> { rotateImage(img.id, -90); });
    div.querySelector('.rotate-right').addEventListener('click', ()=> { rotateImage(img.id, 90); });
    div.querySelector('.crop').addEventListener('click', ()=> { openCrop(img.id); });
    div.querySelector('.remove').addEventListener('click', ()=> { removeImage(img.id); });
  });

  // Enable reorder via SortableJS
  Sortable.create(thumbsEl, {
    animation: 150,
    onEnd(evt){
      const oldIndex = evt.oldIndex, newIndex = evt.newIndex;
      if(oldIndex === newIndex) return;
      const moved = images.splice(oldIndex,1)[0];
      images.splice(newIndex,0,moved);
      renderThumbs();
    }
  });

  updateCount();
}

/* escape simple html */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* Rotate image */
function rotateImage(id, deg){
  const it = images.find(i=>i.id===id);
  if(!it) return;
  it.rotation = (it.rotation + deg + 3600) % 360;
  // rotate visual preview by drawing to canvas immediately to update dataUrl
  applyTransformsToImage(it).then(() => renderThumbs());
}

/* Remove image */
function removeImage(id){
  images = images.filter(i=>i.id!==id);
  renderThumbs();
}

/* Apply rotation/crop to produce a new dataURL (non-destructive if desired). We'll mutate dataUrl for previews. */
async function applyTransformsToImage(imgObj){
  // Load image
  const img = await loadImage(imgObj.dataUrl);
  // create canvas sized to crop or full image
  let sx=0, sy=0, sW=img.width, sH=img.height;
  if(imgObj.cropData){
    sx = imgObj.cropData.x; sy = imgObj.cropData.y;
    sW = imgObj.cropData.width; sH = imgObj.cropData.height;
  }
  // create offscreen canvas
  const tmp = document.createElement('canvas');
  // consider rotation and swap dims if needed
  const rot = (imgObj.rotation || 0) % 360;
  if(rot % 180 === 0){
    tmp.width = sW; tmp.height = sH;
  } else {
    tmp.width = sH; tmp.height = sW;
  }
  const ctx = tmp.getContext('2d');
  // apply rotation about center
  ctx.translate(tmp.width/2, tmp.height/2);
  ctx.rotate(rot * Math.PI / 180);
  ctx.drawImage(img, sx, sy, sW, sH, -sW/2, -sH/2, sW, sH);
  const newDataUrl = tmp.toDataURL('image/png');
  imgObj.dataUrl = newDataUrl;
  // update width/height to reflect new image
  imgObj.width = tmp.width; imgObj.height = tmp.height;
}

/* load image as HTMLImageElement from dataURL */
function loadImage(dataUrl){
  return new Promise((res, rej)=>{
    const im = new Image();
    im.onload = ()=> res(im);
    im.onerror = rej;
    im.src = dataUrl;
  });
}

/* Crop modal logic (Cropper.js) */
const modal = document.getElementById('modal');
const cropImgEl = document.getElementById('cropImg');
const cropApply = document.getElementById('cropApply');
const cropCancel = document.getElementById('cropCancel');
const cropRotateLeft = document.getElementById('cropRotateLeft');
const cropRotateRight = document.getElementById('cropRotateRight');
const cropReset = document.getElementById('cropReset');

function openCrop(id){
  const idx = images.findIndex(i=>i.id===id);
  if(idx === -1) return;
  currentCropIndex = idx;
  const obj = images[idx];
  cropImgEl.src = obj.dataUrl;
  modal.classList.add('show');
  modal.setAttribute('aria-hidden','false');

  // create cropper
  if(cropper) cropper.destroy();
  cropper = new Cropper(cropImgEl, {
    viewMode: 1,
    autoCropArea: 0.9,
    responsive: true,
    background: false,
    zoomOnWheel: true,
    rotatable: true
  });

  cropRotateLeft.onclick = ()=> cropper.rotate(-90);
  cropRotateRight.onclick = ()=> cropper.rotate(90);
  cropReset.onclick = ()=> cropper.reset();
}

cropCancel.addEventListener('click', ()=> {
  closeCrop();
});
cropApply.addEventListener('click', async ()=> {
  if(currentCropIndex == null) return;
  const cData = cropper.getData(true); // get data relative to image natural size
  // cData keys: x, y, width, height, rotate, scaleX, scaleY
  // We'll apply cropping + rotation to the image data and update images[currentCropIndex].dataUrl
  const obj = images[currentCropIndex];
  // create canvas to store cropped result
  const img = await loadImage(obj.dataUrl);
  const canvas = document.createElement('canvas');
  canvas.width = Math.round(cData.width);
  canvas.height = Math.round(cData.height);
  const ctx = canvas.getContext('2d');
  // handle rotation by drawing into temp then using rotate transforms if needed
  // We use drawImage with the crop rectangle from source image (natural coordinates)
  ctx.drawImage(img, cData.x, cData.y, cData.width, cData.height, 0, 0, cData.width, cData.height);
  const newDataUrl = canvas.toDataURL('image/png');
  obj.dataUrl = newDataUrl;
  obj.width = canvas.width; obj.height = canvas.height;
  // clear cropData, rotation reset because applied
  obj.cropData = null;
  obj.rotation = 0;
  closeCrop();
  renderThumbs();
});

function closeCrop(){
  modal.classList.remove('show');
  modal.setAttribute('aria-hidden','true');
  if(cropper){ cropper.destroy(); cropper = null; }
  currentCropIndex = null;
}

/* Apply EXIF orientation to correct images automatically */
async function autoOrientAll(){
  status('Auto-orienting images...');
  for(const it of images){
    const o = it.exifOrientation || 1;
    if(o === 1) continue;
    // convert orientation to rotation/flip
    const canvasResult = await applyExifOrientation(it.dataUrl, o);
    it.dataUrl = canvasResult;
    it.rotation = 0;
    it.exifOrientation = 1;
  }
  renderThumbs();
  status('Auto-orient complete');
}
document.getElementById('btnAutoOrient').addEventListener('click', autoOrientAll);

/* apply EXIF orientation */
async function applyExifOrientation(dataUrl, orientation){
  const img = await loadImage(dataUrl);
  const w = img.naturalWidth, h = img.naturalHeight;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  if(orientation >=5 && orientation <=8){
    canvas.width = h; canvas.height = w;
  } else {
    canvas.width = w; canvas.height = h;
  }
  // transform context based on orientation (1 normal)
  switch(orientation){
    case 2: ctx.transform(-1,0,0,1,w,0); break; // flip horizontal
    case 3: ctx.translate(w,h); ctx.rotate(Math.PI); break; // rotate 180
    case 4: ctx.transform(1,0,0,-1,0,h); break; // flip vertical
    case 5: ctx.transform(0,1,1,0,0,0); break; // transpose
    case 6: ctx.translate(h,0); ctx.rotate(Math.PI/2); break; // rotate 90
    case 7: ctx.transform(0,-1,-1,0,h,w); break; // transverse
    case 8: ctx.translate(0,w); ctx.rotate(-Math.PI/2); break; // rotate -90
    default: break;
  }
  ctx.drawImage(img,0,0);
  return canvas.toDataURL('image/png');
}

/* Simple rotation via canvas for preview update implemented earlier on rotateImage */

/* Escape hatch for buttons */
document.getElementById('btnRotateLeft').addEventListener('click', ()=>{
  // rotate selected? We'll rotate all images (global) for convenience
  images.forEach(i=> i.rotation = (i.rotation - 90 + 360) % 360);
  Promise.all(images.map(i=> applyTransformsToImage(i))).then(()=> renderThumbs());
});
document.getElementById('btnRotateRight').addEventListener('click', ()=>{
  images.forEach(i=> i.rotation = (i.rotation + 90) % 360);
  Promise.all(images.map(i=> applyTransformsToImage(i))).then(()=> renderThumbs());
});
document.getElementById('btnCrop').addEventListener('click', ()=>{
  // open crop on first image as convenience
  if(images.length>0) openCrop(images[0].id);
});

/* Generate PDF logic */
btnGenerate.addEventListener('click', ()=> generatePDF({preview:false}));
btnPreview.addEventListener('click', ()=> generatePDF({preview:true}));

/* Page size calculation */
function computePageSizePoints(){
  const preset = pageSizeEl.value;
  let wPt, hPt;
  if(preset === 'Custom'){
    const wmm = parseFloat(customW.value) || 210;
    const hmm = parseFloat(customH.value) || 297;
    wPt = mmToPoints(wmm); hPt = mmToPoints(hmm);
  } else if(preset === 'A4'){
    const p = PAGE_PRESETS.A4;
    wPt = mmToPoints(p.w_mm); hPt = mmToPoints(p.h_mm);
  } else {
    // inches values
    const p = PAGE_PRESETS[preset];
    const wIn = p.w_in; const hIn = p.h_in;
    wPt = wIn * 72; hPt = hIn * 72;
  }
  if(orientationEl.value === 'landscape') [wPt,hPt] = [hPt,wPt];
  return {wPt, hPt};
}

/* Main generator */
async function generatePDF({ preview=false } = {}){
  if(images.length === 0){ alert('Add images first'); return; }
  btnGenerate.disabled = true;
  btnPreview.disabled = true;
  progress(0);
  status('Preparing PDF...');

  try{
    const pdfDoc = await PDFDocument.create();
    const title = document.getElementById('pdfTitle').value.trim();
    const author = document.getElementById('pdfAuthor').value.trim();
    const subject = document.getElementById('pdfSubject').value.trim();
    if(title) pdfDoc.setTitle(title);
    if(author) pdfDoc.setAuthor(author);
    if(subject) pdfDoc.setSubject(subject);

    const { wPt, hPt } = computePageSizePoints();
    const marginMM = parseFloat(marginsEl.value) || 10;
    const marginPt = mmToPoints(marginMM);

    const fitMode = fitModeEl.value;
    const quality = parseFloat(qualityEl.value);
    const dpi = parseInt(dpiEl.value,10) || 150;
    const embedAsJpg = embedAsJpgEl.checked;
    const watermarkText = watermarkTextEl.value.trim();
    const watermarkOpacity = parseFloat(watermarkOpacityEl.value) || 0.25;
    const watermarkSize = parseFloat(watermarkSizeEl.value) || 24;
    const watermarkPos = watermarkPosEl.value;
    const pagesCount = images.length;

    for(let idx=0; idx<pagesCount; idx++){
      const imgObj = images[idx];
      status(`Processing image ${idx+1} / ${pagesCount}`);
      progress( Math.round((idx/pagesCount) * 100) );

      // prepare processed image as Blob via canvas (apply quality & dpi)
      const processed = await renderImageForPdf(imgObj, { dpi, quality, fitMode, targetPtWidth: wPt - 2*marginPt, targetPtHeight: hPt - 2*marginPt });
      // processed: { mime, blob, width_px, height_px }

      // embed into pdf-lib
      let embeddedImage;
      if(embedAsJpg && processed.mime === 'image/png'){
        // try converting PNG to JPEG to save space
        const jpegBlob = await blobToJpeg(processed.blob, quality);
        const arrayBuf = await jpegBlob.arrayBuffer();
        embeddedImage = await pdfDoc.embedJpg(arrayBuf);
      } else if(processed.mime === 'image/png'){
        const arrayBuf = await processed.blob.arrayBuffer();
        embeddedImage = await pdfDoc.embedPng(arrayBuf);
      } else if(processed.mime.startsWith('image/jpeg')){
        const arrayBuf = await processed.blob.arrayBuffer();
        embeddedImage = await pdfDoc.embedJpg(arrayBuf);
      } else {
        // fallback to PNG embed
        const arrayBuf = await processed.blob.arrayBuffer();
        embeddedImage = await pdfDoc.embedPng(arrayBuf);
      }

      const page = pdfDoc.addPage([wPt, hPt]);
      // calculate placement based on fit mode
      const targetW = wPt - 2*marginPt;
      const targetH = hPt - 2*marginPt;
      const imgWpt = (processed.width_px / processed.dpi) * 72; // px / dpi * 72
      const imgHpt = (processed.height_px / processed.dpi) * 72;
      let drawW = imgWpt, drawH = imgHpt;

      if(fitMode === 'contain'){
        const scale = Math.min(targetW / imgWpt, targetH / imgHpt, 1);
        drawW = imgWpt * scale; drawH = imgHpt * scale;
      } else if(fitMode === 'cover'){
        const scale = Math.max(targetW / imgWpt, targetH / imgHpt);
        drawW = imgWpt * scale; drawH = imgHpt * scale;
      } else if(fitMode === 'stretch'){
        drawW = targetW; drawH = targetH;
      } else if(fitMode === 'center'){
        drawW = imgWpt; drawH = imgHpt;
      }

      // compute coordinates to center within margins
      let x = marginPt + (targetW - drawW)/2;
      let y = marginPt + (targetH - drawH)/2;

      // If center mode and image bigger than target, clip to page edges by aligning center but image may overflow - pdf-lib will draw outside but page size remains. We'll simply center.
      page.drawImage(embeddedImage, { x, y, width: drawW, height: drawH });

      // watermark
      if(watermarkText){
        const helv = await pdfDoc.embedFont(StandardFonts.Helvetica);
        const wmSize = watermarkSize;
        const textWidth = helv.widthOfTextAtSize(watermarkText, wmSize);
        const textHeight = helv.heightAtSize(wmSize);
        let tx = 0, ty = 0;
        if(watermarkPos === 'center'){ tx = (wPt - textWidth)/2; ty = (hPt - wmSize)/2; }
        if(watermarkPos === 'top-left'){ tx = marginPt; ty = hPt - marginPt - wmSize; }
        if(watermarkPos === 'top-right'){ tx = wPt - marginPt - textWidth; ty = hPt - marginPt - wmSize; }
        if(watermarkPos === 'bottom-left'){ tx = marginPt; ty = marginPt; }
        if(watermarkPos === 'bottom-right'){ tx = wPt - marginPt - textWidth; ty = marginPt; }
        page.drawText(watermarkText, {
          x: tx, y: ty,
          size: wmSize,
          font: helv,
          color: rgb(0,0,0),
          opacity: watermarkOpacity,
        });
      }

      // small delay permit UI update
      await sleep(10);
    }

    progress(100);
    status('Finalizing PDF...');
    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], {type:'application/pdf'});
    if(preview){
      // open first page as blob URL in new tab
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
    } else {
      saveAs(blob, outNameEl.value || 'document.pdf');
    }
    status('Done');
  } catch (err){
    console.error(err);
    alert('Error: ' + (err.message || err));
    status('Error');
  } finally {
    btnGenerate.disabled = false;
    btnPreview.disabled = false;
    progress(0);
  }
}

/* Helper: Render image into properly sized canvas blob suitable for embedding, respecting DPI and quality.
   Return object: { mime, blob, width_px, height_px, dpi }
*/
async function renderImageForPdf(imgObj, { dpi=150, quality=0.9, fitMode='contain', targetPtWidth, targetPtHeight }){
  // load image
  const img = await loadImage(imgObj.dataUrl);
  // apply rotation if present (we assume rotation already applied to dataUrl for thumbnails; but ensure)
  // compute target pixel dimensions: targetPtWidth is in points; convert to px targetPx = targetPt * dpi / 72
  const targetPxW = Math.round(targetPtWidth * dpi / 72);
  const targetPxH = Math.round(targetPtHeight * dpi / 72);

  let srcW = img.naturalWidth, srcH = img.naturalHeight;
  // determine effective draw size in px based on fit mode
  let drawW = srcW, drawH = srcH;
  if(fitMode === 'contain'){
    const scale = Math.min(targetPxW / srcW, targetPxH / srcH, 1);
    drawW = Math.round(srcW * scale); drawH = Math.round(srcH * scale);
  } else if(fitMode === 'cover'){
    const scale = Math.max(targetPxW / srcW, targetPxH / srcH);
    drawW = Math.round(srcW * scale); drawH = Math.round(srcH * scale);
  } else if(fitMode === 'stretch'){
    drawW = targetPxW; drawH = targetPxH;
  } else if(fitMode === 'center'){
    drawW = srcW; drawH = srcH;
  }

  // create canvas sized to drawW x drawH (but ensure at least 1px)
  const canvas = document.createElement('canvas');
  canvas.width = Math.max(1, drawW);
  canvas.height = Math.max(1, drawH);
  const ctx = canvas.getContext('2d');

  // fill white background for JPEG compatibility
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw scaled image
  ctx.drawImage(img, 0, 0, srcW, srcH, 0,0, canvas.width, canvas.height);

  // produce blob (JPEG or PNG based on preference)
  const preferJpg = embedAsJpgEl.checked;
  let mime = 'image/png';
  let blob;
  if(preferJpg){
    blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
    mime = 'image/jpeg';
  } else {
    // Use PNG to preserve transparency if present
    // If PNG and original had no alpha consider converting to JPEG to save space - but user chose checkbox to control that
    blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
    mime = 'image/png';
  }
  return { mime, blob, width_px: canvas.width, height_px: canvas.height, dpi };
}

/* convert blob PNG -> JPEG */
async function blobToJpeg(blob, quality=0.9){
  const url = URL.createObjectURL(blob);
  const img = await loadImage(url);
  const canvas = document.createElement('canvas');
  canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.drawImage(img,0,0);
  return new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
}

/* small helpers */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function progress(p){ progressBar.style.width = (p) + '%'; }
function status(s){ statusEl.textContent = s; }

/* Convert canvas element width style to progress */
(function initUI(){
  // custom page size toggle
  pageSizeEl.addEventListener('change', ()=> {
    if(pageSizeEl.value === 'Custom') customSizeRow.style.display = 'flex';
    else customSizeRow.style.display = 'none';
  });

  // initial render
  renderThumbs();
})();

/* simple debug utility to log image info */
function listImages(){
  console.table(images.map(i=>({name:i.name, w:i.width, h:i.height, rot:i.rotation})));
}

/* Expose listImages in window for debugging (dev only) */
window.listImages = listImages;

/* initial status */
status('Idle');

</script>
</body>
</html>
